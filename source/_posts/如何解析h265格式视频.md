\---

title: 如何解析h265格式视频

date: 2023-07-25 09:25:42

tags:

\---

# 打印文件

## 1、react-to-print

```
import ReactToPrint from 'react-to-print';
```

```tsx
 <ReactToPrint
                  trigger={() => (
                    <Button icon={<PrinterOutlined />} onClick={() => printRef?.current}>
                      打印
                    </Button>
                  )}
                  content={() => printRef.current || null}
                />
```

直接默认导出一个组件，content是一个函数，返回值是组件的真实DOM。trigger作为函数返回一个在页面上显示此功能的标签

# 公式编辑器（可交互）

## 1、react-mathquill

```tsx
import React, { useState, useEffect, useRef } from 'react';
import { addStyles, EditableMathField } from 'react-mathquill';

import type { MathField } from 'react-mathquill';
import { Button } from 'antd';

import { editData } from './editData';

// inserts the required css to the <head> block.
// you can skip this, if you want to do that by yourself.
addStyles();

const MyMathEditor = (props: {
  value: string;
  id: string;
  placeholder: string;
  onMyFinish: (
    index: number,
    value: string,
    answerType: TinsoMiniQuestion.UserInputAnswerType,
  ) => void;
}) => {
  const { id, placeholder, onMyFinish, value } = props;
  const [latex, setLatex] = useState<string | undefined>(value);

  const [edit, setEdit] = useState<MathField>();
  const bthsRef = useRef<HTMLDivElement | null>(null);
  const placeholderRef = useRef<HTMLSpanElement | null>(null);
  let timer: NodeJS.Timeout | null = null;
  const myId = +(id || 0) - 1;
  useEffect(() => {
    document.addEventListener('click', (e) => {
      const path = e.composedPath();
      if (
        !path.some(
          (r: any) =>
            r.className &&
            r.className.includes &&
            r.className.includes(`editMath`),
        )
      ) {
        (bthsRef.current as any).style.display = 'none';
      }
    });
    return () => {
      document.removeEventListener('click', () => {});
    };
  }, []);

  useEffect(() => {}, [latex]);

  return (
    <div className={`editMath`} style={{ position: 'relative' }}>
      <EditableMathField
        className="edit"
        style={{ minWidth: '100px', border: 0 }}
        latex={latex}
        onBlur={() => {
          timer = setTimeout(() => {
            onMyFinish(myId, edit?.latex() || '', 'text');
          }, 100);

          const myPlaceholder = placeholderRef.current;
          if (myPlaceholder) {
            (myPlaceholder as any).style.display = 'inline';
          }
        }}
        onFocus={() => {
          if (timer) clearTimeout(timer);
          const myPlaceholder = placeholderRef.current;
          if (myPlaceholder) {
            (myPlaceholder as any).style.display = 'none';
          }
          const allBtn = document.querySelectorAll('.editAllBtn');
          for (let i = 0; i < allBtn.length; i++) {
            const e = allBtn[i];
            (e as any).style.display = 'none';
          }

          const btn2 = bthsRef.current;
          (btn2 as any).style.display = 'flex';

          edit?.focus();
        }}
        onInput={(e) => {
          const data = (e.target as any).value;
          (e.target as any).value = '';

          if (data?.length > 1) {
              //单个汉字或者字母输入时，data长度为1，下方代码不运行
            edit?.write(data);
            setLatex(edit?.latex());
          }
        }}
        onChange={(mathField) => {
          setLatex(mathField.latex());
        }}
        mathquillDidMount={(mathField) => {
          setEdit(mathField);
        }}
      />
      <span
        ref={(e) => (placeholderRef.current = e)}
        style={{
          position: 'absolute',
          top: '0px',
          left: '2px',
          zIndex: '10',
          pointerEvents: 'none',
          color: '#aaa',
        }}
      >
        {latex ? '' : placeholder}
      </span>
      <div
        ref={(e) => (bthsRef.current = e)}
        className={`editAllBtn edit${id}`}
        style={{
          border: '1px solid #eee',
          width: '300px',
          display: 'none',
          justifyContent: 'flex-start',
          alignItems: 'flex-start',
          flexWrap: 'wrap',
          zIndex: '20',
          position: 'absolute',
          backgroundColor: '#fff',
          marginTop: '4px',
        }}
      >
        {editData.map((item) => (
          <Button
            tabIndex={-1}
            className="btn"
            onClick={(e) => {
              e.stopPropagation();

              edit?.focus();
              edit?.write(item.data);

              setLatex(edit?.latex());
              let theStep = 0;
              while (theStep < (item.step || 0)) {
                edit?.keystroke('Left');
                theStep++;
              }
            }}
            style={{
              width: '40px',
              height: '40px',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              margin: '10px',
            }}
            key={item.id}
          >
            <div dangerouslySetInnerHTML={{ __html: item.descri }} />
          </Button>
        ))}
      </div>
    </div>
  );
};

export { MyMathEditor };

```

react-mathquill会导出addStyles函数和EditableMathField组件。

在代码最顶层运行addStyles，加载公式编辑器器所需要的全部样式。

EditableMathField：公式编辑器的组件(本代码对编辑器进行二次封装，实现了点击按钮和中文输入功能)

1. latex：latex公式的字符串，组件会将公式字符串渲染成可编辑的公式
2. onBlur：组件方法，编辑器失去焦点触发
3. onFocus：组件方法，编辑器获取焦点触发
4. mathquillDidMount：组件方法，当组件首次渲染时触发，自带参数为组件的实例对象
5. onChange：组件方法，组件重写的原生<input/>中onChange方法，当编辑器中的公式改变时触发
6. onInput：继承自原生<input/>中onInput方法，类似onChange（主要为了让编辑器支持中文输入）；

主要逻辑：

1. 在mathquillDidMount方法中获取组件的实例mathField，便于后面调用组件上的方法。当在编辑器中手动输入数据时候，会同时调用onChange和onInput方法，因为单个字母输入时，此时输入的值的长度为1，所以onInput后面不运行。当使用中文输入法输入时，此时输入的内容长度大于2，运行onInput，而当输入中文时，onChange又不运行（完美）
2. 当进行按钮快捷输入时，因为点在了编辑器以外的地方，造成其失去焦点，进而不能触发Button组件的onClick事件，解决方法是给按钮外层的div设置一个className，然后通过addEventListener事件监听每次的点击事件，获取此次点击元素的className，如果这些className里面不包含有那个div的className，就把元素的display设置成none，有就什么都不执行。所以在点击按钮时，因为有对应的classname，元素正常存在，触发onclick，先让编辑器聚焦（因为点击时候因为点击点不在编辑器上，会失去焦点），在使用edit?.write方法向编辑器写入公式。
3. 当点在其他地方时（非编辑器和按钮部分），没有对应的classname，元素失去焦点。
4. 编辑器聚焦时，获取所有与编辑器对应的外层div。把所有的div的display设成none，再使用ref获取当前点击的编辑器实例，把当前的设置成之前的flex；（效果就死其他的按钮都关了，就当前这个是开着的）；
5. 当编辑器失去焦点时，会向后端发送内容修改请求，如果此时，在100ms内又获取了这个编辑器的焦点，则请求不发送（因为在点击快捷输入按钮时，页面会经历一个快速的失焦，和聚焦的过程，此设置为了节流）；



# 视频播放器

## 1、flv-h265.js

```tsx
import React, { useRef, useState, useEffect } from 'react';
import type { CSSProperties } from 'react';
import ReactPlayer from 'react-player';
import styles from './index.less';
import Flv from 'flv-h265.js';
import type { ReactPlayerProps } from 'react-player';
//用于进行视频预览
const VideoPreview: React.FC<{
  src: string;
  width?: string | number;
  height?: string | number;
  previewStyle?: CSSProperties;
  playing?: boolean;
}> = (props) => {
  const { src, previewStyle, playing } = props;
  const videoRef = useRef<ReactPlayerProps>();
  const [myVideo, setMyVideo] = useState<HTMLVideoElement>();
  const onReady = () => {
    const divBox: any = videoRef.current?.wrapper;
    const myVideo2: HTMLVideoElement = divBox?.querySelector('video') as HTMLVideoElement;
    setMyVideo(myVideo2);
    console.log(ReactPlayer);
  };
  useEffect(() => {
    if (!myVideo) return;
    const flvPlayer = Flv.createPlayer({
      type: 'mp4',
      url: src,
    });

    flvPlayer.attachMediaElement(myVideo as HTMLVideoElement);
    flvPlayer.load();
    flvPlayer.play();

    return () => {
      flvPlayer.pause();
      flvPlayer.unload();
    };
  }, [myVideo]);
  return (
    <ReactPlayer
      ref={(e) => (videoRef.current = e as ReactPlayerProps)}
      onReady={onReady}
      config={{ file: { attributes: { controlsList: 'nodownload' } } }}
      playing={playing}
      controls
      url={src}
      // width和height不可写入样式中，否则会被默认的“width:680px;height:320px;”覆盖
      width="100%"
      height="100%"
      style={{
        ...previewStyle,
      }}
      className={styles.previewVideo}
    />
  );
};
export default VideoPreview;

```

主要逻辑：flv-h265.js库暴露一个对象，使用该对象中的createPlayer创建一个解码用的实例flvPlayer（要设置解码文件的类型，这里解码的是MP4文件和解码文件的路径，还可以配置其他配置），使用实例上的attachMediaElement方法传入播放器的真实DOM，load（）加载，play（）播放。在页面销毁时，暂停pause，停止加载unload